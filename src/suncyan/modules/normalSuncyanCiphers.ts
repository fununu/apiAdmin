'use strict'

/**
 * 선시안 표준 암호화 모듈
 * 버전: 1.0.0
 */
import Crypto from 'crypto'


 const ALGORITHM = 'aes-256-gcm';
 const BLOCK_SIZE_BYTES = 16; // 128 bit

 class Aes256Gcm {

   constructor() { }
   /**
    * Encrypts text with AES 256 GCM.
    * @param {string} text - Cleartext to encode.
    * @param {string} secret - Shared secret key, must be 32 bytes.
    * @returns {object}
    */
   static encrypt(text: string, secret: string): {ciphertext: string, iv: string, tag: string} {
     const iv = Crypto.randomBytes(BLOCK_SIZE_BYTES);
     const cipher = Crypto.createCipheriv(ALGORITHM, secret, iv);
 
     let ciphertext = cipher.update(text, 'utf8', 'base64');
     ciphertext += cipher.final('base64');
     return {
       ciphertext,
       iv: iv.toString('base64'),
       tag: cipher.getAuthTag().toString('base64'),
     };
   }
 
   /**
    * Decrypts AES 256 CGM encrypted text.
    * @param {string} ciphertext - Base64-encoded ciphertext.
    * @param {string} iv - The base64-encoded initialization vector.
    * @param {string} tag - The base64-encoded authentication tag generated by getAuthTag().
    * @param {string} secret - Shared secret key, must be 32 bytes.
    * @returns {string}
    */
   static decrypt (ciphertext: string, iv: string, tag: string, secret: string): string {
     const decipher = Crypto.createDecipheriv(ALGORITHM, secret, Buffer.from(iv, 'base64'));
     decipher.setAuthTag(Buffer.from(tag, 'base64'));
 
     let cleartext = decipher.update(ciphertext, 'base64', 'utf8');
     cleartext += decipher.final('utf8');
 
     return cleartext;
   }
 }
 

export interface S {
    encrypt_AES256CBC (plain_data: Buffer, shared_key: string): {IV: Buffer, encryptedData: Buffer};
    decrypt_AES256CBC (encryptedData: Buffer, shared_key: string, IV: Buffer): Buffer;
    encrypt_AES256GCM (text: string, secret: string): {ciphertext: string, iv: string, tag: string};
    decrypt_AES256GCM (ciphertext: string, iv: string, tag: string, secret: string): string;
    HMAC256_base64 (data: Crypto.BinaryLike, KEY: Crypto.BinaryLike): string;
}

export const encrypt_AES256CBC = (plain_data: Buffer, shared_key: string | Crypto.BinaryLike) => {
    const IV: Buffer = Crypto.randomBytes(16);
    const cipher: Crypto.Cipher = Crypto.createCipheriv('aes-256-cbc', shared_key, IV);
    let encryptedData: Buffer = cipher.update(plain_data);
    encryptedData = Buffer.concat([encryptedData, cipher.final()]);

    return {IV, encryptedData};
}
export const decrypt_AES256CBC = (encryptedData: Buffer, shared_key: string, IV: Buffer) => {

    const decipher = Crypto.createDecipheriv('aes-256-cbc', shared_key, IV);
    let decryptedData = decipher.update(encryptedData)
    decryptedData =  Buffer.concat([decryptedData, decipher.final()])

    return decryptedData
}
export const HMAC256_base64 = (data: Crypto.BinaryLike, KEY: Crypto.BinaryLike) => {
    return Crypto.createHmac('sha256', KEY).update(data).digest('base64').replace(/=/g, "");
}

export const encrypt_AES256GCM = Aes256Gcm.encrypt;
export const decrypt_AES256GCM = Aes256Gcm.decrypt;


const s: S = {
    encrypt_AES256CBC: encrypt_AES256CBC,
    decrypt_AES256CBC: decrypt_AES256CBC,
    encrypt_AES256GCM: encrypt_AES256GCM,
    decrypt_AES256GCM: decrypt_AES256GCM,
    HMAC256_base64: HMAC256_base64,
}
export default s;
